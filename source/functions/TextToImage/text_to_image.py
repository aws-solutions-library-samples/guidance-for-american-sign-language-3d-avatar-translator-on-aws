import boto3,json,os,base64
import math
import time

from text2Image_helper import write_file_to_s3, check_image_moderation

sns = boto3.client('sns')
aws_region = boto3.Session().region_name
bedrock_client = boto3.client(
        service_name='bedrock-runtime', 
        region_name=aws_region,
        endpoint_url=f'https://bedrock-runtime.{aws_region}.amazonaws.com'
    )
s3_client = boto3.client('s3', config=boto3.session.Config(signature_version='s3v4'))
from botocore.exceptions import ClientError

def create_presigned_get(bucket_name, object_name):
    params = {
            'Bucket': bucket_name,
            'Key': object_name
          }

    try:
        response = s3_client.generate_presigned_url(
            ClientMethod='get_object',
            HttpMethod='GET',
            Params=params,
            ExpiresIn=120
        )
    except ClientError as e:
        print(e)
        return None

    return response

    
def lambda_handler(event, context):
    
    print(f"event is {event}")
    bodyis = json.loads(event['body'])
    print(f"body is is {bodyis}") 
    imageInputDetails=bodyis['imageInputDetails']

    try:
        bedrock_response = run_bedrock_fm(imageInputDetails)
        result_url = create_presigned_get(bedrock_response["bucketname"], bedrock_response["imagename"])
        message = {
                    "Action": "CHANGE_BACKGROUND",
                    "Data":result_url,
                    "kwargs": {
                    "model":"stable diffusion"
                            }
                    }
        print(f"publish message to sns :: {message}")
        delay_between_invoking = float(10.0)
        next_epoch = str(math.ceil(time.time()/delay_between_invoking)*int(delay_between_invoking))
        
        sns_response = sns.publish(
            TopicArn=os.environ['snsTopicArn'],
            Message=json.dumps(message),
            MessageStructure='string',
            MessageDeduplicationId=next_epoch,
            MessageGroupId='2'
        )

        dictionary = {
            'download_url': result_url,
            'result': 'success',
        }

        return {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json; charset=UTF-8'
            },
            'body': json.dumps(dictionary)
        }
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps(e)
        }

def run_bedrock_fm(input_params):
    print('starting text2Image agent with bedrock fm using input_params {}::', input_params)
    image_name=input_params['imagename']
    response={
        "imagename":image_name,
        "bucketname":"",
        "inputText":input_params['inputText'],
        "generateImageJobStatus":"Failed",
        "message":'',
        "encodedimage":""
    }

    if(len(input_params['inputText'])==0):
        response["message"]="Input text is empty."
    else:
        bedrock_response = invoke_bedrock(input_params)
        parsed_reponse = parse_response(bedrock_response)
        if(parsed_reponse['image_generated_status']=='Failed'):
            response["message"]="No image generated by bedrock API, Please check the prompt"
        else:
            img= parsed_reponse['image_generated']
            imageGenerated=write_file_to_s3(img,image_name)

            image_moderation_response=check_image_moderation(imageGenerated["bucket_name"],imageGenerated["image_name"])
            if(image_moderation_response['isToxic']==True):
                response["message"]="In-appropriate image generated."
            else:
                response={
                    "imagename":imageGenerated["image_name"],
                    "bucketname":imageGenerated["bucket_name"],
                    "inputText":input_params['inputText'],
                    "generateImageJobStatus":"Completed",
                    "message":"Image generated successfully",
                    "encodedimage":img
                    }

    print (f"response :: {response}")
    return response


def parse_response(query_response):
    """Parse response and return generated image and the prompt"""

    response_dict = json.loads(query_response['body'].read())
    parsed_reponse={
        "image_generated":'',
        "image_generated_status":'Success'
    }
    #print(f"response_dict :: {response_dict}")
    if(response_dict['artifacts'] is None):
         parsed_reponse['image_generated_status']='Failed'
    else:
        parsed_reponse['image_generated']=response_dict['artifacts'][0]["base64"]
    return parsed_reponse

        
def invoke_bedrock(input_params):
   
    input_text=input_params['inputText']
    cfg_scale=input_params['bedrockParameters']['cfg_scale']
    seed=input_params['bedrockParameters']['seed']
    steps=input_params['bedrockParameters']['steps']
   
    print(f"invoke foundation model with input_text :: {input_text}")

    promptTemplate="{\"text_prompts\":[{\"text\":\"$input_text\\n\"}],\"cfg_scale\":$cfg_scale,\"seed\":$seed,\"steps\":$steps}"
    prompt=promptTemplate.replace("$input_text", input_text).replace("$cfg_scale", str(cfg_scale)).replace("$seed", str(seed)).replace("$steps", str(steps))
    print(f" prompt :: {prompt}")

    return bedrock_client.invoke_model(
        modelId= "stability.stable-diffusion-xl",
        contentType= "application/json",
        accept= "application/json",
        body=prompt
        )
    

